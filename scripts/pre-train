#!/usr/bin/env python3

import argparse
import glob
import os.path
import random
import subprocess
import sys

import keras.saving
import matplotlib.pyplot as plt
import numpy as np
import tensorflow as tf
import yaml
from keras.layers import Conv2D, Input, MaxPooling2D, UpSampling2D
from keras.models import Model

from clean_document.utils import data_augmentation_image

NUMBER_OF_IMAGES = 5
IMAGE_DIMENSION = 256


def model_32_64():
    input_img = Input(shape=(None, None, 3), name="image_input")

    # Encoder
    x = Conv2D(32, (3, 3), activation="relu", padding="same", name="Conv1")(input_img)
    x = MaxPooling2D((2, 2), padding="same", name="pool1")(x)
    x = Conv2D(64, (3, 3), activation="relu", padding="same", name="Conv2")(x)
    x = MaxPooling2D((2, 2), padding="same", name="pool2")(x)

    # Decoder
    x = Conv2D(64, (3, 3), activation="relu", padding="same", name="Conv3")(x)
    x = UpSampling2D((2, 2), name="upsample1")(x)
    x = Conv2D(32, (3, 3), activation="relu", padding="same", name="Conv4")(x)
    x = UpSampling2D((2, 2), name="upsample2")(x)
    x = Conv2D(3, (3, 3), activation="sigmoid", padding="same", name="Conv5")(x)

    # Model
    autoencoder = Model(inputs=input_img, outputs=x)
    autoencoder.compile(optimizer="adam", loss="binary_crossentropy")

    return autoencoder


def model_64_128() -> Model:
    input_img = Input(shape=(None, None, 3), name="image_input")

    # Encoder
    x = Conv2D(64, (3, 3), activation="relu", padding="same", name="ConvEnc1")(input_img)
    x = MaxPooling2D((2, 2), padding="same", name="pool1")(x)
    x = Conv2D(128, (3, 3), activation="relu", padding="same", name="ConvEnc2")(x)
    x = MaxPooling2D((2, 2), padding="same", name="pool2")(x)

    # Decoder
    x = Conv2D(128, (3, 3), activation="relu", padding="same", name="ConvDec1")(x)
    x = UpSampling2D((2, 2), name="upsample1")(x)
    x = Conv2D(64, (3, 3), activation="relu", padding="same", name="ConvDec2")(x)
    x = UpSampling2D((2, 2), name="upsample2")(x)
    x = Conv2D(3, (3, 3), activation="sigmoid", padding="same", name="ConvDec3")(x)

    # Model
    autoencoder = Model(inputs=input_img, outputs=x)
    autoencoder.compile(optimizer="adam", loss="binary_crossentropy")

    return autoencoder


def model_64_128_256() -> Model:
    input_img = Input(shape=(None, None, 3), name="image_input")

    # Encoder
    x = Conv2D(64, (3, 3), activation="relu", padding="same", name="ConvEnc1")(input_img)
    x = MaxPooling2D((2, 2), padding="same", name="pool1")(x)
    x = Conv2D(128, (3, 3), activation="relu", padding="same", name="ConvEnc2")(x)
    x = MaxPooling2D((2, 2), padding="same", name="pool2")(x)
    x = Conv2D(256, (3, 3), activation="relu", padding="same", name="ConvEnc3")(x)
    x = MaxPooling2D((2, 2), padding="same", name="pool3")(x)

    # Decoder
    x = Conv2D(256, (3, 3), activation="relu", padding="same", name="ConvDec1")(x)
    x = UpSampling2D((2, 2), name="upsample1")(x)
    x = Conv2D(128, (3, 3), activation="relu", padding="same", name="ConvDec2")(x)
    x = UpSampling2D((2, 2), name="upsample2")(x)
    x = Conv2D(64, (3, 3), activation="relu", padding="same", name="ConvDec3")(x)
    x = UpSampling2D((2, 2), name="upsample3")(x)
    x = Conv2D(3, (3, 3), activation="sigmoid", padding="same", name="ConvDec4")(x)

    # Model
    autoencoder = Model(inputs=input_img, outputs=x)
    autoencoder.compile(optimizer="adam", loss="binary_crossentropy")

    return autoencoder


MODELS = {
    f"model_{IMAGE_DIMENSION}_YUV_32_64": model_32_64,
    f"model_{IMAGE_DIMENSION}_YUV_64_128": model_64_128,
    f"model_{IMAGE_DIMENSION}_YUV_64_128_256": model_64_128_256,
}


# Generator that returns the images
class Images:
    def __init__(self, filenames: list[str]):
        self.filenames = filenames

    def __call__(self):
        print("Call")
        for filename in self.filenames:
            images = data_augmentation_image(filename, IMAGE_DIMENSION, save=False)
            for image in images:
                image = image.astype("float32") / 255.0
                image = np.expand_dims(image, axis=0)
                yield image, image


def train_many(model_name: str, filenames: list[str], test: list[str]) -> None:
    if os.path.exists(f"results/{model_name}.keras"):
        model = keras.saving.load_model(f"results/{model_name}.keras")
    else:
        model = MODELS[model_name]()
    if not os.path.exists(f"results/{model_name}.summary"):
        with open(f"results/{model_name}.summary", "w", encoding="utf-8") as summary_file:
            model.summary(print_fn=lambda x: summary_file.write(x + "\n"))

    # create a tf.data.Dataset.from_generator that returns to numpy array od shape (255, 255, 3
    train = tf.data.Dataset.from_generator(
        Images(filenames),
        output_signature=(
            tf.TensorSpec(shape=(None, None, None, 3), dtype=tf.float32),
            tf.TensorSpec(shape=(None, None, None, 3), dtype=tf.float32),
        ),
    )
    val = tf.data.Dataset.from_generator(
        Images(test),
        output_signature=(
            tf.TensorSpec(shape=(None, None, None, 3), dtype=tf.float32),
            tf.TensorSpec(shape=(None, None, None, 3), dtype=tf.float32),
        ),
    )

    try:
        if os.path.exists(f"results/{model_name}-history.yaml"):
            with open(f"results/{model_name}-history.yaml", encoding="utf-8") as history_file:
                history = yaml.load(history_file.read(), Loader=yaml.SafeLoader)
        else:
            history = {
                "loss": [],
                "val_loss": [],
            }
        hist = model.fit(
            train,
            validation_data=val,
        )
        history.setdefault("loss", []).append(hist.history["loss"])
        history.setdefault("val_loss", []).append(hist.history["val_loss"])

        plt.plot(history["loss"])
        plt.plot(history["val_loss"])
        plt.title("Model loss")
        plt.ylabel("Loss")
        plt.legend(["Train", "Test"], loc="upper left")
        # Save plot to file
        plt.savefig(f"results/{model_name}.png")

        # Save the model
        model.save(f"results/{model_name}.keras", overwrite=True)
        with open(f"results/{model_name}-history.yaml", "w", encoding="utf-8") as history_file:
            history_file.write(yaml.dump(history))
        return
    except Exception as e:
        print(f"Failed to train model {model_name}: {e}")
        raise e


def _main() -> None:
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "--name",
        default=f"model_{IMAGE_DIMENSION}_YUV_32_64",
        help="The name of the model, " + ", ".join(MODELS.keys()),
    )
    parser.add_argument("--file", action="append", help="The files to process")
    parser.add_argument("--test", action="append", help="The test files")

    args = parser.parse_args()

    if args.file:
        train_many(args.name, args.file, args.test)
    else:
        if os.path.exists(f"results/{args.name}-status.yaml"):
            with open(f"results/{args.name}-status.yaml", encoding="utf-8") as status_file:
                status = yaml.load(status_file.read(), Loader=yaml.SafeLoader)
        else:
            files = list(glob.glob("clean-data/*.png"))
            random.shuffle(files)
            status = {
                "files": files,
                "index": 0,
                "epoch": 0,
                "test_files": list(glob.glob("clean-test/*.png")),
            }

        filenames = status["files"]

        while status["index"] < len(filenames):
            files = filenames[status["index"] : status["index"] + NUMBER_OF_IMAGES]
            print("=" * 18)
            print(f"Epoch {status['epoch']} {status['index']}/{len(filenames)}")
            print("=" * 18)

            cmd = [sys.argv[0], f"--name={args.name}"]
            cmd += [f"--file={filename}" for filename in files]
            cmd += [f"--test={filename}" for filename in status["test_files"]]
            subprocess.run(cmd, check=True)

            status["index"] += NUMBER_OF_IMAGES
            with open(f"results/{args.name}-status.yaml", "w", encoding="utf-8") as status_file:
                status_file.write(yaml.dump(status))


if __name__ == "__main__":
    _main()
